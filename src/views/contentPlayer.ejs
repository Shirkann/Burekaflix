<!DOCTYPE html>
<html lang="he" dir="rtl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>× ×’×Ÿ ×ª×•×›×Ÿ - BurekaFlix</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="/css/main.css" />
  </head>
  <body>
    <main class="container-fluid position-relative p-0">
      <video id="contentPlayer" class="w-100" preload="metadata"></video>
      <div class="player-controls">
        <button id="playPauseBtn" class="btn btn-primary">× ×’×Ÿ â–¶ï¸</button>
        <button id="rewindBtn" class="btn btn-secondary">â© 10 ×©× ×™×•×ª</button>
        <button id="forwardBtn" class="btn btn-secondary">10 ×©× ×™×•×ª âª</button>
        <button id="fullscreenBtn" class="btn btn-secondary">××¡×š ××œ× ğŸ–¥ï¸</button>
        <button id="episodesToggleBtn" class="btn btn-outline-info">
          ×¨×©×™××ª ×¤×¨×§×™×
        </button>
        <button id="nextEpisodeBtn" class="btn btn-success">×¤×¨×§ ×”×‘× â­ï¸</button>
        <button id="startoverBtn" class="btn btn-secondary">×”×ª×—×œ ××—×“×© ğŸ”„</button>
        <button id="backBtn" class="btn btn-outline-light">×—×–×¨×”</button>
      </div>
      <div class="timeline"><div class="timeline-progress"></div></div>
      <aside
        id="episodeDrawer"
        class="position-absolute bottom-0 end-0 bg-dark text-white p-3 d-none"
        style="width: 300px; max-height: 100%; overflow-y: auto"
      >
        <h6 class="border-bottom pb-2">×¤×¨×§×™×</h6>
        <ul id="episodesList" class="list-unstyled mb-0"></ul>
      </aside>
      <body style="visibility: hidden;">

    </main>

    <script>
      function getId() {
        const parts = window.location.pathname.split("/").filter(Boolean);
        return parts[parts.length - 2]; // /content/:id/player
      }

      const player = document.getElementById("contentPlayer");
      const playPauseBtn = document.getElementById("playPauseBtn");
      const rewindBtn = document.getElementById("rewindBtn");
      const forwardBtn = document.getElementById("forwardBtn");
      const fullscreenBtn = document.getElementById("fullscreenBtn");
      const episodesToggleBtn = document.getElementById("episodesToggleBtn");
      const nextEpisodeBtn = document.getElementById("nextEpisodeBtn");
      const backBtn = document.getElementById("backBtn");
      const timeline = document.querySelector(".timeline");
      const timelineProgress = document.querySelector(".timeline-progress");
      const episodeDrawer = document.getElementById("episodeDrawer");
      const episodesList = document.getElementById("episodesList");
      const startoverBtn = document.getElementById("startoverBtn");
      let contentData = null;

      const progressTracker = (() => {
        const endpoint = "/api/continue-watching";
        const reportInterval = 5;
        let currentVideo = null;
        let lastReported = 0;

        async function fetchSaved(videoName) {
          try {
            const resp = await fetch(
              `${endpoint}/${encodeURIComponent(videoName)}`,
              {
                headers: { Accept: "application/json" },
              }
            );
            if (!resp.ok) {
              if (resp.status !== 404) {
                console.warn("Failed to load saved progress", resp.status);
              }
              return 0;
            }
            const data = await resp.json();
            const saved = Number(data.seconds);
            return Number.isFinite(saved) && saved > 0 ? saved : 0;
          } catch (err) {
            console.warn("Failed to fetch saved progress", err);
            return 0;
          }
        }

        function seekWhenReady(seconds) {
          if (!seconds || seconds <= 0) return;
          const apply = () => {
            try {
              player.currentTime = seconds;
            } catch (err) {
              console.warn("Failed to seek saved position", err);
            }
          };
          if (player.readyState >= 1) {
            apply();
          } else {
            player.addEventListener("loadedmetadata", apply, { once: true });
          }
        }

        function sendPayload(seconds, duration) {
          if (!currentVideo || !Number.isFinite(seconds)) return;
          const payload = { videoName: currentVideo, seconds };
          if (Number.isFinite(duration) && duration > 0) {
            payload.duration = Math.floor(duration);
          }
          const body = JSON.stringify(payload);
          try {
            if (navigator.sendBeacon) {
              const blob = new Blob([body], { type: "application/json" });
              navigator.sendBeacon(endpoint, blob);
            } else {
              fetch(endpoint, {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  Accept: "application/json",
                },
                body,
              });
            }
          } catch (err) {
            console.warn("Failed to send progress update", err);
          }
        }

        function start(videoName) {
          if (!videoName) {
            console.warn("Missing video file name");
            return false;
          }
          if (currentVideo && currentVideo !== videoName) {
            report(true);
          }
          currentVideo = videoName;
          lastReported = 0;
          timelineProgress.style.width = "0%";
          player.src = "/videos/" + encodeURIComponent(videoName);
          fetchSaved(videoName).then(seekWhenReady);
          return true;
        }

        function report(force = false) {
          if (!currentVideo) return;
          const current = Number(player.currentTime);
          if (!Number.isFinite(current) || current < 0) return;
          const seconds = Math.floor(current);
          const rawDuration = Number(player.duration);
          const duration =
            Number.isFinite(rawDuration) && rawDuration > 0
              ? Math.floor(rawDuration)
              : 0;

          if (!force) {
            if (Math.abs(seconds - lastReported) < reportInterval) return;
            if (duration > 0 && seconds >= duration - 1) return;
          }

          lastReported = seconds;
          sendPayload(seconds, duration);
        }

        function complete() {
          if (!currentVideo) return;
          const rawDuration = Number(player.duration);
          if (!Number.isFinite(rawDuration) || rawDuration <= 0) return;
          const duration = Math.floor(rawDuration);
          lastReported = duration;
          sendPayload(duration, duration);
        }

        return { start, report, complete };
      })();

      function setVideoSource(fileName) {
        return progressTracker.start(fileName);
      }

      async function loadContent() 
      {
        try {
          const id = getId();
          const resp = await fetch("/api/content/" + encodeURIComponent(id));
          if (!resp.ok) throw new Error("×©×’×™××” ×‘×˜×¢×™× ×ª ×”×ª×•×›×Ÿ");
          contentData = await resp.json();
          if ((contentData.type || "").toLowerCase() === "movie") {
            episodesToggleBtn.classList.add("d-none");
            nextEpisodeBtn.classList.add("d-none");
            if (!contentData.videoUrl) {
              throw new Error("×œ× × ××¦× ×§×•×‘×¥ ×•×™×“××•");
            }
            setVideoSource(contentData.videoUrl);
          } else {
            if (
              Array.isArray(contentData.episodes) &&
              contentData.episodes.length
            ) {
              const params = new URLSearchParams(window.location.search);
              let epIndex = Number.parseInt(params.get("ep"), 10);
              if (!Number.isFinite(epIndex) || epIndex < 0 || epIndex >= contentData.episodes.length) {
                epIndex = 0;
              }
              setVideoSource(contentData.episodes[epIndex]);
              buildEpisodes(contentData.episodes);
            } else {
              throw new Error("×œ× × ××¦××• ×¤×¨×§×™×");
            }
          }
          player.play().catch(() => {});
          playPauseBtn.textContent = "â¸ï¸";
        } catch (e) {
          console.error(e);
          alert(e.message);
        }
        document.body.style.visibility = "visible";

      }

      function buildEpisodes(list) {
        episodesList.innerHTML = "";
        if (!Array.isArray(list) || !list.length) {
          episodesList.innerHTML = '<li class="text-muted">××™×Ÿ ×¤×¨×§×™×</li>';
          return;
        }
        list.forEach((fileName, i) => {
          // fileName is the episode video file name (string)
          const li = document.createElement("li");
          li.className = "mb-1";
          li.innerHTML =
            '<button class="btn btn-sm btn-outline-light w-100 text-start" data-index="' +
            i +
            '">×¤×¨×§ ' +
            (i + 1) +
            "</button>";
          episodesList.appendChild(li);
        });
        highlightCurrentEpisode();
      }

      function highlightCurrentEpisode() {
        if (!contentData || !Array.isArray(contentData.episodes)) return;
        const currentIndex = contentData.episodes.findIndex(
          (fn) =>
            player.src.includes(encodeURIComponent(fn)) ||
            player.src.endsWith(fn)
        );
        [...episodesList.querySelectorAll("button[data-index]")].forEach(
          (btn) => {
            if (Number(btn.dataset.index) === currentIndex) {
              btn.classList.remove("btn-outline-light");
              btn.classList.add("btn-primary");
            } else {
              btn.classList.remove("btn-primary");
              btn.classList.add("btn-outline-light");
            }
          }
        );
      }

      playPauseBtn.addEventListener("click", () => {
        if (player.paused) {
          player.play();
          playPauseBtn.textContent = "â¸ï¸";
        } else {
          player.pause();
          playPauseBtn.textContent = "â–¶ï¸";
        }
      });

      rewindBtn.addEventListener("click", () => {
        player.currentTime = Math.max(0, player.currentTime - 10);
      });

      forwardBtn.addEventListener("click", () => {
        player.currentTime = Math.min(player.duration, player.currentTime + 10);
      });

        startoverBtn.addEventListener("click", () => {
        player.currentTime = 0;
      });

      fullscreenBtn.addEventListener("click", () => {
        if (!document.fullscreenElement) {
          player.requestFullscreen();
        } else {
          document.exitFullscreen();
        }
      });
      episodesToggleBtn.addEventListener("click", () => {
        episodeDrawer.classList.toggle("d-none");
      });
      episodesList.addEventListener("click", (e) => {
        const btn = e.target.closest("button[data-index]");
        if (!btn || !contentData) return;
        const idx = Number(btn.dataset.index);
        const fileName = contentData.episodes[idx];
        if (setVideoSource(fileName)) {
          player.play();
          playPauseBtn.textContent = "×”×©×”×”";
          highlightCurrentEpisode();
        } else {
          alert("××™×Ÿ ×•×™×“××• ×œ×¤×¨×§ ×”×–×”");
        }
      });
      nextEpisodeBtn.addEventListener("click", () => {
        if (!contentData || !Array.isArray(contentData.episodes))
          return alert("××™×Ÿ ×¤×¨×§×™×");
        const currentIndex = contentData.episodes.findIndex(
          (fn) =>
            player.src.includes(encodeURIComponent(fn)) ||
            player.src.endsWith(fn)
        );
        const next = contentData.episodes[currentIndex + 1];
        if (setVideoSource(next)) {
          player.play();
          playPauseBtn.textContent = "×”×©×”×”";
          highlightCurrentEpisode();
        } else alert("××™×Ÿ ×¤×¨×§ × ×•×¡×£");
      });
      backBtn.addEventListener("click", () => {
        history.back();
      });

      player.addEventListener("timeupdate", () => {
        const duration = Number(player.duration) || 0;
        const current = Number(player.currentTime) || 0;
        const progress = duration > 0 ? (current / duration) * 100 : 0;
        timelineProgress.style.width = `${Math.min(progress, 100)}%`;
        highlightCurrentEpisode();
        progressTracker.report();
      });

      player.addEventListener("ended", () => {
        progressTracker.complete();
      });

      timeline.addEventListener("click", (e) => {
        const rect = timeline.getBoundingClientRect();
        const clickPosition = e.clientX - rect.left;
        const duration = Number(player.duration) || 0;
        const percentage = 1 - (clickPosition / rect.width);
        player.currentTime = percentage * duration;
      });

      window.addEventListener("beforeunload", () => {
        progressTracker.report(true);
      });

      loadContent();
    </script>
  </body>
</html>
